template <typename Traits>
struct SubstitutionKernelLDLT
{
    using blocks_type     = typename Traits::blocks_type;     // ArrayX<MatrixXd>
    using index_sets_type = typename Traits::index_sets_type; // ArrayX<ArrayX<int_t>>
    using reordering_type = typename Traits::reordering_type;
    using value_ptr_type  = typename Traits::value_ptr_type;
    using block_type      = typename Traits::block_type;
    using index_type      = typename Traits::index_type;
    using pattern_type    = typename Traits::pattern_type;
    using index_array_type= typename Traits::index_array_type;
    // ...

    static void forward(MatrixRef<block_type>    X,
                        const blocks_type&       DBlocks,
                        const blocks_type&       UBlocks,
                        const index_sets_type&   nnzIndSets,
                        const reordering_type&   reorderingData,
                        value_ptr_type           vals);

    static void backward(MatrixRef<block_type>   X,
                         const blocks_type&      DBlocks,
                         const blocks_type&      UBlocks,
                         const index_sets_type&  nnzIndSets,
                         const reordering_type&  reorderingData,
                         value_ptr_type          vals);

private:
    static void forward_solve_node(
        MatrixRef<block_type>   X,
        const blocks_type&      DBlocks,
        const blocks_type&      UBlocks,
        const index_sets_type&  nnzIndSets,
        const reordering_type&  reorderingData,
        value_ptr_type          vals,
        index_type              i);

    static void backward_solve_node(
        MatrixRef<block_type>   X,
        const blocks_type&      DBlocks,
        const blocks_type&      UBlocks,
        const index_sets_type&  nnzIndSets,
        const reordering_type&  reorderingData,
        value_ptr_type          vals,
        index_type              i);

    // ... get_leaf_offdiag_blocks 保持不变 ...
};
