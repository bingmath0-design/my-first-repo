#include "separate_substitution.h"
#include "blas_interface.h"
#include "dense_matrix.h"
#include "lapack_interface.h"

#include <algorithm> // std::lower_bound, std::max
#include <cassert>   // assert
#include <utility>   // std::forward, std::declval

namespace hplinalg
{

    //======================================================================
    // 1. Local traits for substitution
    //
    //    Similar idea to the block-factorization file: encapsulate concrete
    //    types behind a small traits layer so that the kernel itself only
    //    depends on a single template parameter.
    //======================================================================

    using SubstBlocks    = ArrayX<MatrixXd>;             // not used directly, but
    using SubstIndexSets = ArrayX<ArrayX<int_t>>;        // kept for symmetry
    using SubstReorder   = ReorderingData;
    using SubstValuePtr  = const double*;

    template <typename BlocksT,
              typename IndexSetsT,
              typename ReorderingT,
              typename ValuePtrT>
    struct substitution_traits;

    // Default specialization matching the current back-end
    template <>
    struct substitution_traits<SubstBlocks,
                               SubstIndexSets,
                               SubstReorder,
                               SubstValuePtr>
    {
        using blocks_type       = SubstBlocks;
        using index_sets_type   = SubstIndexSets;
        using reordering_type   = SubstReorder;
        using value_ptr_type    = SubstValuePtr;

        using block_type        = MatrixXd;
        using index_type        = int_t;
        using pattern_type      = CSR3Matrix<int_t>;
        using index_array_type  = ArrayX<index_type>;

        using nodes_container_type =
            decltype(std::declval<reordering_type>().dissectionData.nodes);

        using block_start_indices_type =
            decltype(std::declval<reordering_type>().dissectionData.blockStartIndices);

        using block_pattern_type =
            decltype(std::declval<reordering_type>().blockPattern);

        static const nodes_container_type &get_nodes(const reordering_type &r)
        {
            return r.dissectionData.nodes;
        }

        static const block_start_indices_type &get_block_start_indices(const reordering_type &r)
        {
            return r.dissectionData.blockStartIndices;
        }

        static const pattern_type &reordered_pattern(const reordering_type &r)
        {
            return r.reorderedPattern;
        }

        static const block_pattern_type &block_pattern(const reordering_type &r)
        {
            return r.blockPattern;
        }

        static inline index_type rows(const block_type& A) 
        {
            return static_cast<index_type>(A.rows());
        }

        static inline index_type cols(const block_type &A)
        {
            return static_cast<index_type>(A.cols());
        }

        // Basic zero-initialization helper
        static inline void set_zero(block_type& A, index_type rows, index_type cols)
        {
            A.setZero(rows, cols);
        }
    };


    //======================================================================
    // 2. Numeric wrappers for BLAS/LAPACK used in substitution
    //======================================================================

    namespace detail
    {

        template <typename F, typename... Args>
        inline auto call_numerics(F&& f, Args&&... args)
            -> decltype(std::forward<F>(f)(std::forward<Args>(args)...))
        {
            return std::forward<F>(f)(std::forward<Args>(args)...);
        }

        template <typename XBlock, typename RBlock>
        inline void solve_pivot(XBlock& X, const RBlock& Rii) {
            call_numerics(lapack_dpotrs, X, Rii);
        }

        template <typename C, typename A, typename B, typename Alpha, typename Beta>
        inline void gemm_t(C& Cblk, Alpha alpha,
                        const A& Ablk, const B& Bblk, Beta beta)
        {
            call_numerics(blas_gemm_t, Cblk, alpha, Ablk, Bblk, beta);
        }

        template <typename C, typename A, typename B, typename Alpha, typename Beta>
        inline void gemm(C& Cblk, Alpha alpha,
                        const A& Ablk, const B& Bblk, Beta beta)
        {
            call_numerics(blas_gemm, Cblk, alpha, Ablk, Bblk, beta);
        }


        //======================================================================
        // 3. Substitution kernel (forward / backward solve) parametrized by Traits
        //
        //    This kernel only depends on a substitution_traits specialization,
        //    plus FactorizationData / ReorderingData layouts.
        //======================================================================

        template <typename Traits>
        struct SubstitutionKernelLDLT
        {
            using blocks_type       = typename Traits::blocks_type;
            using index_sets_type   = typename Traits::index_sets_type;
            using reordering_type   = typename Traits::reordering_type;
            using value_ptr_type    = typename Traits::value_ptr_type;

            using block_type        = typename Traits::block_type;
            using index_type        = typename Traits::index_type;
            using pattern_type      = typename Traits::pattern_type;
            using index_array_type  = typename Traits::index_array_type;

            using nodes_container_type         = typename Traits::nodes_container_type;
            using block_start_indices_type     = typename Traits::block_start_indices_type;
            using block_pattern_type           = typename Traits::block_pattern_type;

            // Public entry points
            static void forward(MatrixRef<block_type> X,
                                const FactorizationData& factorizationData,
                                const reordering_type&   reorderingData,
                                value_ptr_type           vals)
            {
                const auto& nodes = Traits::get_nodes(reorderingData);
                const index_type nNodes =
                    static_cast<index_type>(nodes.size());

                // Forward substitution through the elimination tree
                for (index_type i = 0; i < nNodes; ++i)
                {
                    forward_solve_node(X, factorizationData, reorderingData, vals, i);
                }
            }

            static void backward(MatrixRef<block_type> X,
                                const FactorizationData& factorizationData,
                                const reordering_type&   reorderingData,
                                value_ptr_type           vals)
            {
                const auto& nodes = Traits::get_nodes(reorderingData);
                const index_type nNodes =
                    static_cast<index_type>(nodes.size());

                // Backward substitution through the elimination tree
                for (index_type i = nNodes - 1; i >= 0; --i)
                {
                    backward_solve_node(X, factorizationData, reorderingData, vals, i);
                }
            }

        private:
            //------------------------------------------------------------------
            // Extract the off-diagonal part of the leaf arrowhead block.
            //
            // This is essentially the same logic as in your original
            // get_leaf_offdiag_blocks implementation, but written in terms of
            // Traits types.
        //------------------------------------------------------------------
            static void get_leaf_offdiag_blocks(
                block_type&          Aij,
                const index_array_type& updateIndices,
                index_type           rowBegin,
                index_type           rowEnd,
                const pattern_type&  reorderedPattern,
                value_ptr_type       vals)
            {
                const auto& reorderedPtrs = reorderedPattern.ptrs;
                const auto& reorderedInds = reorderedPattern.inds;
                const auto& reorderedVals = reorderedPattern.vals;

                const index_type nRow = rowEnd - rowBegin;
                const index_type nCol =
                    static_cast<index_type>(updateIndices.size());

                Traits::set_zero(Aij, nRow, nCol);

                const index_type offdiagCutoffCol = rowEnd; // columns >= rowEnd are off-diagonal
                index_array_type offdiagOffsetsPerRow(nRow); // offset of off-diagonal part in each row

                // Precompute per-row offsets into the off-diagonal segment
                for (index_type r = rowBegin; r < rowEnd; ++r)
                {
                    const index_type localRow = r - rowBegin;
                    const index_type rowNnzBegin = reorderedPtrs[r];
                    const index_type rowNnzEnd   = reorderedPtrs[r + 1];

                    const index_type* rowColBegin = &reorderedInds[rowNnzBegin];
                    const index_type* rowColEnd   = &reorderedInds[rowNnzEnd];

                    auto offdiagColBegin =
                        std::lower_bound(rowColBegin, rowColEnd, offdiagCutoffCol);

                    offdiagOffsetsPerRow[localRow] =
                        static_cast<index_type>(offdiagColBegin - rowColBegin);
                }

                // Now scan each update column, following the per-row cursors
                for (index_type localCol = 0; localCol < nCol; ++localCol)
                {
                    const index_type globalCol = updateIndices[localCol];

                    for (index_type localRow = 0; localRow < nRow; ++localRow)
                    {
                        auto& cursor = offdiagOffsetsPerRow[localRow];

                        const index_type r  = rowBegin + localRow;
                        const index_type rs = reorderedPtrs[r] + cursor;

                        if (cursor >= reorderedPtrs[r + 1] ||
                            reorderedInds[rs] != globalCol)
                        {
                            continue;
                        }

                        Aij(localRow, localCol) = vals[reorderedVals[rs]];
                        ++cursor;
                    }
                }
            }

            //------------------------------------------------------------------
            // Forward solve for a single node in the elimination tree.
            //------------------------------------------------------------------
            static void forward_solve_node(MatrixRef<block_type> X,
                                           const FactorizationData& factorizationData,
                                           const reordering_type&   reorderingData,
                                           value_ptr_type           vals,
                                           index_type               i)
            {
                const auto& nodes             = Traits::get_nodes(reorderingData);
                const auto& blockStartIndices = Traits::get_block_start_indices(reorderingData);
                const auto& blockPattern      = Traits::block_pattern(reorderingData);
                const auto& reorderedPattern  = Traits::reordered_pattern(reorderingData);

                const auto& node      = nodes[i];
                const auto& nodeFactors = factorizationData.nodeFactors;
                const auto& nodeFactor  = nodeFactors[i];

                const index_type blockRowStart = blockPattern.ptrs[i];
                const index_type blockRowEnd   = blockPattern.ptrs[i + 1];

                const auto& nnzIndices = nodeFactor.nnzIndices;
                const auto& Rii        = nodeFactor.diagBlock;

                const block_type* ui = &nodeFactor.UBlock;
                block_type Ui0;

                // Leaf node: reconstruct the arrowhead off-diagonal block from A,
                // then solve with Rii to obtain the proper Ui.
                if (node.isLeaf())
                {
                    get_leaf_offdiag_blocks(
                        Ui0, nnzIndices,
                        blockStartIndices[i], blockStartIndices[i + 1],
                        reorderedPattern, vals);

                    solve_pivot(Ui0, Rii);
                    ui = &Ui0;
                }
                const block_type& Ui = *ui;

                // Determine a reasonable temporary buffer size for updates
                index_type maxUpdateSize = 0;
                for (index_type ij = blockRowStart + 1; ij < blockRowEnd; ++ij)
                {
                    const index_type j  = blockPattern.inds[ij];
                    const auto& Uj      = nodeFactors[j].UBlock;
                    const index_type updateSize =
                        static_cast<index_type>(Uj.rows()) +
                        static_cast<index_type>(Uj.cols());
                    maxUpdateSize = std::max(maxUpdateSize, updateSize);
                }

                block_type Tmp;
                if (maxUpdateSize > 0)
                {
                    Tmp.resize(maxUpdateSize, Traits::cols(X));
                }

                // Apply updates from the current node to its ancestors
                const index_type blockSizeI =
                    blockStartIndices[i + 1] - blockStartIndices[i];

                MatrixRef<block_type> Xi =
                    X.middleRows(blockStartIndices[i], blockSizeI);

                for (index_type ij = blockRowStart + 1; ij < blockRowEnd; ++ij)
                {
                    const index_type j = blockPattern.inds[ij];
                    const auto& updateIndicesJ = nodeFactors[j].nnzIndices;
                    const index_type nUpdateIndexJ =
                        static_cast<index_type>(updateIndicesJ.size());

                    if (nUpdateIndexJ == 0)
                        continue;

                    MatrixRef<block_type> deltaX = Tmp.topRows(nUpdateIndexJ);

                    // deltaX = - Ui * Xi
                    gemm_t(deltaX, -1.0, Ui, Xi, 0.0);

                    for (index_type localRow = 0; localRow < nUpdateIndexJ; ++localRow)
                    {
                        const index_type globalRow = updateIndicesJ[localRow];
                        X.row(globalRow) += deltaX.row(localRow);
                    }
                }

                // Solve for Xi with the diagonal block Rii
                solve_pivot(Xi, Rii);
            }

            //------------------------------------------------------------------
            // Backward solve for a single node in the elimination tree.
            //------------------------------------------------------------------
            static void backward_solve_node(MatrixRef<block_type> X,
                                            const FactorizationData& factorizationData,
                                            const reordering_type&   reorderingData,
                                            value_ptr_type           vals,
                                            index_type               i)
            {
                const auto& nodes             = Traits::get_nodes(reorderingData);
                const auto& blockStartIndices = Traits::get_block_start_indices(reorderingData);
                const auto& blockPattern      = Traits::block_pattern(reorderingData);
                const auto& reorderedPattern  = Traits::reordered_pattern(reorderingData);

                const auto& node      = nodes[i];
                const auto& nodeFactors = factorizationData.nodeFactors;
                const auto& nodeFactor  = nodeFactors[i];

                const index_type blockRowStart = blockPattern.ptrs[i];
                const index_type blockRowEnd   = blockPattern.ptrs[i + 1];

                const auto& nnzIndices = nodeFactor.nnzIndices;
                const auto& Rii        = nodeFactor.diagBlock;

                const block_type* ui = &nodeFactor.UBlock;
                block_type Ui0;

                if (node.isLeaf())
                {
                    get_leaf_offdiag_blocks(
                        Ui0, nnzIndices,
                        blockStartIndices[i], blockStartIndices[i + 1],
                        reorderedPattern, vals);

                    solve_pivot(Ui0, Rii);
                    ui = &Ui0;
                }
                const block_type& Ui = *ui;

                index_type maxUpdateSize = 0;
                for (index_type ij = blockRowStart + 1; ij < blockRowEnd; ++ij)
                {
                    const index_type j = blockPattern.inds[ij];
                    maxUpdateSize = std::max(
                        maxUpdateSize,
                        static_cast<index_type>(nodeFactors[j].nnzIndices.size()));
                }
                // This assertion is kept from the original implementation.
                assert(maxUpdateSize == 0);

                block_type Tmp;
                if (maxUpdateSize > 0)
                {
                    Tmp.resize(maxUpdateSize, Traits::cols(X));
                }

                const index_type blockSizeI =
                    blockStartIndices[i + 1] - blockStartIndices[i];

                MatrixRef<block_type> Xi =
                    X.middleRows(blockStartIndices[i], blockSizeI);

                // Apply updates from ancestors to the current node
                for (index_type ij = blockRowStart + 1; ij < blockRowEnd; ++ij)
                {
                    const index_type j = blockPattern.inds[ij];
                    const auto& updateIndicesJ = nodeFactors[j].nnzIndices;
                    const index_type nUpdateIndexJ =
                        static_cast<index_type>(updateIndicesJ.size());

                    if (nUpdateIndexJ == 0)
                        continue;

                    MatrixRef<block_type> Xjc = Tmp.topRows(nUpdateIndexJ);

                    for (index_type localRow = 0; localRow < nUpdateIndexJ; ++localRow)
                    {
                        const index_type globalRow = updateIndicesJ[localRow];
                        Xjc.row(localRow) = X.row(globalRow);
                    }

                    // Xi += - Ui * Xjc
                    gemm(Xi, -1.0, Ui, Xjc, 1.0);
                }
            }
        };

    } // namespace detail


    //======================================================================
    // 4. Public interface
    //
    //    These are the functions used by the rest of the code. Internally
    //    they just instantiate the substitution kernel with the default
    //    traits and call its forward/backward entry points.
    //======================================================================

    void forward_solve(MatrixRef<MatrixXd> X,
                       const FactorizationData& factorizationData,
                       const ReorderingData&   reorderingData,
                       const double*           vals)
    {
        using Traits = substitution_traits<
            SubstBlocks,
            SubstIndexSets,
            SubstReorder,
            SubstValuePtr>;

        detail::SubstitutionKernelLDLT<Traits>::forward(
            X, factorizationData, reorderingData, vals);
    }

    void backward_solve(MatrixRef<MatrixXd> X,
                        const FactorizationData& factorizationData,
                        const ReorderingData&   reorderingData,
                        const double*           vals)
    {
        using Traits = substitution_traits<
            SubstBlocks,
            SubstIndexSets,
            SubstReorder,
            SubstValuePtr>;

        detail::SubstitutionKernelLDLT<Traits>::backward(
            X, factorizationData, reorderingData, vals);
    }

} // namespace hplinalg
