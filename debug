// block_ldlt_utils.h
#pragma once

#include <cassert>
#include <algorithm> // std::lower_bound
#include <numeric>   // std::iota

#include "types.h"
#include "merge_arrays.h"
#include "lapack_interface.h"
#include "blas_interface.h"
#include "block_factorization.h" // for MatrixXd, ReorderingData, CSR3Matrix, ArrayX, ArrayView

namespace hplinalg {
namespace detail {

    /// @brief Selects one of two types based on a boolean condition.
    /// This is a small alias for std::conditional to keep template
    /// code more readable.
    template <bool B, class T, class F>
    using conditional_t = typename std::conditional<B, T, F>::type;

    /// @brief A read-only view into selected columns of a matrix block.
    ///
    /// The matrix is stored as a MatrixRef, while the column indices
    /// are stored as a view over an integer array.
    struct InMatrixView
    {
        MatrixRef<const MatrixXd> block;   ///< n_rows x |indices|
        ArrayView<const int_t>&   indices; ///< |indices| == block.cols()

        InMatrixView(MatrixRef<const MatrixXd> m, ArrayView<const int_t>& j)
            : block(m)
            , indices(j)
        {}
    };

    /// @brief A writable view into selected columns of a matrix block.
    ///
    /// The matrix is stored as a reference, while the column indices
    /// are stored as a mutable array.
    struct OutMatrixView
    {
        MatrixXd&     block;   ///< n_rows x |indices|
        ArrayX<int_t>& indices;///< |indices| == block.cols()

        OutMatrixView(MatrixXd& m, ArrayX<int_t>& j)
            : block(m)
            , indices(j)
        {}
    };

    /// @name View factory helpers
    /// @{

    inline InMatrixView make_in_view(MatrixRef<const MatrixXd> M,
                                     ArrayView<const int_t>& J)
    {
        return InMatrixView(M, J);
    }

    inline InMatrixView make_in_view(MatrixXd& M,
                                     ArrayView<const int_t>& J)
    {
        return InMatrixView(MatrixRef<const MatrixXd>(M), J);
    }

    inline InMatrixView make_in_view(MatrixRef<const MatrixXd> M,
                                     const ArrayX<int_t>& J)
    {
        ArrayView<const int_t> JView(J.data(),
                                     static_cast<index_t>(J.size()));
        return InMatrixView(M, JView);
    }

    inline OutMatrixView make_out_view(MatrixXd& M,
                                       ArrayX<int_t>& J)
    {
        return OutMatrixView(M, J);
    }

    /// @}

    /// @brief Extend an assembled block by adding contributions from
    ///        multiple child blocks.
    ///
    /// Given several blocks that share some subset of column indices,
    /// this routine:
    ///   1. Builds the union of all column index sets,
    ///   2. Resizes the assembled block accordingly,
    ///   3. Accumulates all contributions into the assembled block.
    ///
    /// Overlapping columns are summed, which is the behavior expected
    /// when combining multiple update blocks along the elimination tree.
    ///
    /// @param assembled      [in/out] Current assembled view: block + cols.
    /// @param childContribs  [in]     Array of child contributions.
    static inline void extend_add_col(OutMatrixView assembled,
                                      ArrayX<InMatrixView>& childContribs)
    {
        auto& assembledCols  = assembled.indices;
        auto& assembledBlock = assembled.block;

        // Make local copies of the original assembled content. These
        // form the first "part" in the union.
        MatrixXd       assembledBlock0(assembledBlock);
        ArrayX<int_t>  assembledCols0(assembledCols);

        const int_t nPartInput =
            static_cast<int_t>(childContribs.size()) + 1;

        ArrayX<ArrayView<const int_t>> partColViews; ///< column sets
        ArrayX<MatrixRef<MatrixXd>>    partBlocks;   ///< block views

        partColViews.reserve(nPartInput);
        partBlocks.reserve(nPartInput);

        int_t nRow = 0;

        // Original assembled block as the first part
        if (assembledBlock0.rows() > 0 && assembledBlock0.cols() > 0)
        {
            partColViews.push_back(
                ArrayView<const int_t>(
                    assembledCols0.data(),
                    static_cast<index_t>(assembledCols0.size())));

            partBlocks.push_back(MatrixRef<MatrixXd>(assembledBlock0));
            nRow = static_cast<int_t>(assembledBlock0.rows());
        }

        // Add each child contribution as a separate part
        for (const auto& part : childContribs)
        {
            const auto& partBlock = part.block;
            const auto& partCols  = part.indices;
            if (partBlock.rows() == 0 || partBlock.cols() == 0)
                continue; // skip empty parts

            partColViews.push_back(partCols);
            partBlocks.push_back(partBlock);

            if (nRow == 0)
                nRow = static_cast<int_t>(partBlock.rows());
            else
                assert(nRow == static_cast<int_t>(partBlock.rows()));
        }

        const index_t nPart = static_cast<index_t>(partBlocks.size());
        if (nPart == 0)
            return; // nothing to do

        if (nPart == 1)
        {
            // Only one non-empty part, directly copy
            assembledCols.assign(partColViews[0].begin(), partColViews[0].end());
            assembledBlock = partBlocks[0];
            return;
        }

        // Build union of column indices across all parts
        UnionInfo unionInfo;
        build_union_from_sorted_arrays_with_maps(unionInfo, partColViews);

        auto&       unionCols = unionInfo.data;      // unique column indices
        const auto& indexMaps = unionInfo.indexMaps; // index maps for each part

        assembledCols.swap(unionCols);

        assert(indexMaps.size() == nPart);
        for (index_t p = 0; p < nPart; ++p)
        {
            assert(indexMaps[p].size() ==
                   static_cast<index_t>(partBlocks[p].cols()));
        }

        // Resize result block
        const int_t nCol =
            static_cast<int_t>(assembledCols.size());
        assembledBlock.setZero(nRow, nCol); // initialize to zero

        // Accumulate parts into the assembled block
        for (index_t p = 0; p < nPart; ++p)
        {
            const auto  partBlock = partBlocks[p];
            const auto& indexMap  = indexMaps[p];
            const index_t nPartCol =
                static_cast<index_t>(partBlock.cols());

            for (index_t partCol = 0; partCol < nPartCol; ++partCol)
            {
                const int_t assembledCol = indexMap[partCol];
                assembledBlock.col(assembledCol) +=
                    partBlock.col(static_cast<int_t>(partCol));
            }
        }
    }

    /// @brief Extract the arrowhead block for a given node in the elimination tree.
    ///
    /// The arrowhead block consists of:
    ///   - a pivot part (diagonal block),
    ///   - an off-diagonal update part.
    ///
    /// Both parts are assembled using the reordered sparsity pattern
    /// and the original matrix values.
    ///
    /// @param[out] arrowhead      Assembled arrowhead block.
    /// @param[out] arrowheadCols  Column indices of the arrowhead block.
    /// @param[in]  rowBeginNode   First row of this node in the reordered matrix.
    /// @param[in]  rowEndNode     One-past-last row of this node in the reordered matrix.
    /// @param[in]  reorderedPattern Reordered CSR3 pattern.
    /// @param[in]  vals           Pointer to original matrix values.
    static inline void get_arrowhead_block(MatrixXd&              arrowhead,
                                           ArrayX<int_t>&         arrowheadCols,
                                           const int_t            rowBeginNode,
                                           const int_t            rowEndNode,
                                           const CSR3Matrix<int_t>& reorderedPattern,
                                           const double*          vals)
    {
        const auto& reorderedPtrs = reorderedPattern.ptrs;
        const auto& reorderedInds = reorderedPattern.inds;
        const auto& reorderedVals = reorderedPattern.vals;

        const int_t nRow          = rowEndNode - rowBeginNode;
        const int_t updateCutoff  = rowEndNode;

        // Collect off-diagonal column indices for each row
        ArrayX<ArrayView<const int_t>> updateColViews(nRow);
        ArrayX<int_t>                  updateColOffset(nRow);

        for (int_t r = rowBeginNode; r < rowEndNode; ++r)
        {
            const int_t localRow = r - rowBeginNode;
            const int_t rowBegin = reorderedPtrs[r];
            const int_t rowEnd   = reorderedPtrs[r + 1];

            const int_t* rowColBegin = &reorderedInds[rowBegin];
            const int_t* rowColEnd   = &reorderedInds[rowEnd];

            // Locate the first column index >= updateCutoff
            auto updateBegin =
                std::lower_bound(rowColBegin, rowColEnd, updateCutoff);

            const index_t updateCount =
                static_cast<index_t>(rowColEnd - updateBegin);

            // Offset relative to rowBegin, used when reading vals
            updateColOffset[localRow] =
                static_cast<int_t>(updateBegin - rowColBegin);

            updateColViews[localRow] =
                ArrayView<const int_t>(updateBegin, updateCount);
        }

        // Build union of update column indices across all rows
        UnionInfo unionInfo;
        build_union_from_sorted_arrays_with_maps(unionInfo, updateColViews);

        const auto& updateCols = unionInfo.data;
        const auto& indexMaps  = unionInfo.indexMaps;

        const int_t nUpdateCol =
            static_cast<int_t>(updateCols.size());
        const int_t nCol = nRow + nUpdateCol;

        // Arrowhead column indices = diagonal rows + off-diagonal columns
        arrowheadCols.resize(nCol);
        std::iota(arrowheadCols.begin(),
                  arrowheadCols.begin() + nRow,
                  rowBeginNode);
        std::copy(updateCols.begin(), updateCols.end(),
                  arrowheadCols.begin() + nRow);

        // Assemble the arrowhead block
        arrowhead.setZero(nRow, nCol);
        MatrixRef<MatrixXd> pivot  = arrowhead.leftCols(nRow);
        MatrixRef<MatrixXd> update = arrowhead.rightCols(nUpdateCol);

        // Fill pivot and update parts
        for (int_t r = rowBeginNode; r < rowEndNode; ++r)
        {
            const int_t localRow = r - rowBeginNode;
            const int_t rowBegin = reorderedPtrs[r];
            const int_t rowEnd   = reorderedPtrs[r + 1];
            const int_t offDiagBegin =
                rowBegin + updateColOffset[localRow];

            // Diagonal block (pivot part)
            for (int_t rs = rowBegin; rs < offDiagBegin; ++rs)
            {
                const int_t s = reorderedInds[rs];
                assert(s >= rowBeginNode && s < rowEndNode);

                const int_t localCol = s - rowBeginNode;
                pivot(localRow, localCol) = vals[reorderedVals[rs]];
            }

            // Off-diagonal part (update block)
            const auto& indexMap = indexMaps[localRow];
            for (int_t kLocal = 0;
                 kLocal < static_cast<int_t>(indexMap.size());
                 ++kLocal)
            {
                const int_t rs       = offDiagBegin + kLocal;
                const int_t localCol = indexMap[kLocal];
                update(localRow, localCol) = vals[reorderedVals[rs]];
            }
        }
    }

} // namespace detail
} // namespace hplinalg
